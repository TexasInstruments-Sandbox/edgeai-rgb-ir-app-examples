From c48d97b655748c350683e2e7cff02631779f10f1 Mon Sep 17 00:00:00 2001
From: Reese Grimsley <r-grimsley@ti.com>
Date: Wed, 18 Dec 2024 22:08:47 +0000
Subject: [PATCH] add RGB IR test with 1:1 match to GST application

---
 tests/CMakeLists.txt                          |   3 +-
 ...x_rgb_ir_capture_display_test_TIOVXvsGST.c | 424 ++++++++++++++++++
 tests/main.c                                  |  42 +-
 3 files changed, 452 insertions(+), 17 deletions(-)
 create mode 100644 tests/app_tiovx_linux_rgb_ir_capture_display_test_TIOVXvsGST.c

diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 21d26b4..62d24c2 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -45,7 +45,8 @@ if ("${TARGET_CPU}" STREQUAL "A72" OR "${TARGET_CPU}" STREQUAL "A53")
 if ("${TARGET_SOC}" STREQUAL "AM62A" OR "${TARGET_SOC}" STREQUAL "J722S")
     list(APPEND
          SRC_FILES
-         app_tiovx_linux_rgb_ir_capture_display_test.c)
+         app_tiovx_linux_rgb_ir_capture_display_test.c
+         app_tiovx_linux_rgb_ir_capture_display_test_TIOVXvsGST.c)
 endif()
 endif()
 endif()
diff --git a/tests/app_tiovx_linux_rgb_ir_capture_display_test_TIOVXvsGST.c b/tests/app_tiovx_linux_rgb_ir_capture_display_test_TIOVXvsGST.c
new file mode 100644
index 0000000..60a8bef
--- /dev/null
+++ b/tests/app_tiovx_linux_rgb_ir_capture_display_test_TIOVXvsGST.c
@@ -0,0 +1,424 @@
+/*
+ *
+ * Copyright (c) 2024 Texas Instruments Incorporated
+ *
+ * All rights reserved not granted herein.
+ *
+ * Limited License.
+ *
+ * Texas Instruments Incorporated grants a world-wide, royalty-free, non-exclusive
+ * license under copyrights and patents it now or hereafter owns or controls to make,
+ * have made, use, import, offer to sell and sell ("Utilize") this software subject to the
+ * terms herein.  With respect to the foregoing patent license, such license is granted
+ * solely to the extent that any such patent is necessary to Utilize the software alone.
+ * The patent license shall not apply to any combinations which include this software,
+ * other than combinations with devices manufactured by or for TI ("TI Devices").
+ * No hardware patent is licensed hereunder.
+ *
+ * Redistributions must preserve existing copyright notices and reproduce this license
+ * (including the above copyright notice and the disclaimer and (if applicable) source
+ * code license limitations below) in the documentation and/or other materials provided
+ * with the distribution
+ *
+ * Redistribution and use in binary form, without modification, are permitted provided
+ * that the following conditions are met:
+ *
+ * *       No reverse engineering, decompilation, or disassembly of this software is
+ * permitted with respect to any software provided in binary form.
+ *
+ * *       any redistribution and use are licensed by TI for use only with TI Devices.
+ *
+ * *       Nothing shall obligate TI to provide you with source code for the software
+ * licensed and provided to you in object code.
+ *
+ * If software source code is provided to you, modification and redistribution of the
+ * source code are permitted provided that the following conditions are met:
+ *
+ * *       any redistribution and use of the source code, including any resulting derivative
+ * works, are licensed by TI for use only with TI Devices.
+ *
+ * *       any redistribution and use of any object code compiled from the source code
+ * and any resulting derivative works, are licensed by TI for use only with TI Devices.
+ *
+ * Neither the name of Texas Instruments Incorporated nor the names of its suppliers
+ *
+ * may be used to endorse or promote products derived from this software without
+ * specific prior written permission.
+ *
+ * DISCLAIMER.
+ *
+ * THIS SOFTWARE IS PROVIDED BY TI AND TI'S LICENSORS "AS IS" AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL TI AND TI'S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <tiovx_modules.h>
+#include <tiovx_utils.h>
+#include <v4l2_capture_module.h>
+#include <kms_display_module.h>
+#include <linux_aewb_module.h>
+
+#include<unistd.h>
+
+#define APP_BUFQ_DEPTH      (2)
+#define APP_NUM_ITERATIONS  (600)
+
+#define INPUT_WIDTH  (2592)
+#define INPUT_HEIGHT (1944)
+
+#define DISPLAY_WIDTH  (1920)
+#define DISPLAY_HEIGHT (1080)
+
+#define WINDOW_WIDTH  (960)
+#define WINDOW_HEIGHT (540)
+
+#define SENSOR_NAME "SENSOR_OX05B1S"
+#define DCC_VISS TIOVX_MODULES_IMAGING_PATH"/ox05b1s/linear/dcc_viss.bin"
+
+#define DEV "/dev/video%d"
+#define SUBDEV "/dev/v4l-subdev%d"
+
+#define NUM_CAMS 2
+
+typedef struct {
+    Pad *pad;
+    Pad *h3a_pad;
+    Pad *aewb_pad;
+    v4l2CaptureHandle *v4l2_handle;
+    AewbHandle *aewb_handle;
+    bool is_IR;
+    kmsDisplayHandle *kms_display_handle;
+} threadParams;
+
+void *viss_rgbir_enqueue(void *params)
+{
+    threadParams *thread_params = (threadParams *)params;
+    Pad *input_pad = thread_params->pad;
+    bool is_IR    = thread_params->is_IR;
+    v4l2CaptureHandle *v4l2_handle = thread_params->v4l2_handle;
+    BufPool *input_buf_pool = input_pad->buf_pool;
+    Pad *h3a_pad = thread_params->h3a_pad;
+    Pad *aewb_pad = thread_params->aewb_pad;
+    BufPool *h3a_buf_pool = h3a_pad->buf_pool;
+    BufPool *aewb_buf_pool = aewb_pad->buf_pool;
+    Buf *buf = NULL;
+
+    for (int i = 0; i < input_pad->bufq_depth; i++) {
+        printf("pre-enqueue buf %d for v4l2\n", i);
+        buf = tiovx_modules_acquire_buf(input_buf_pool);
+        v4l2_capture_enqueue_buf(v4l2_handle, buf);
+    }
+
+    v4l2_capture_start(v4l2_handle);
+
+    for (int i = 0; i < APP_NUM_ITERATIONS; i++) {
+        do {
+            buf = v4l2_capture_dqueue_buf(v4l2_handle);
+        } while (buf == NULL);
+        tiovx_modules_enqueue_buf(buf);
+
+        if (is_IR == false)
+        {
+            buf = tiovx_modules_acquire_buf(h3a_buf_pool);
+            tiovx_modules_enqueue_buf(buf);
+
+            buf = tiovx_modules_acquire_buf(aewb_buf_pool);
+            tiovx_modules_enqueue_buf(buf);
+        }
+    }
+
+    v4l2_capture_stop(v4l2_handle);
+
+    pthread_exit(NULL);
+}
+
+void *viss_rgbir_dequeue(void *params)
+{
+    threadParams *thread_params = (threadParams *)params;
+    Pad *input_pad = thread_params->pad;
+    bool is_IR = thread_params->is_IR;
+    v4l2CaptureHandle *v4l2_handle = thread_params->v4l2_handle;
+    BufPool *input_buf_pool = input_pad->buf_pool;
+    Buf *buf = NULL;
+    Pad *h3a_pad = thread_params->h3a_pad;
+    Pad *aewb_pad = thread_params->aewb_pad;
+    AewbHandle *aewb_handle = thread_params->aewb_handle;
+    BufPool *h3a_buf_pool = h3a_pad->buf_pool;
+    BufPool *aewb_buf_pool = aewb_pad->buf_pool;
+    Buf *h3a_buf = NULL, *aewb_buf = NULL;
+
+    for (int i = 0; i < APP_NUM_ITERATIONS; i++) {
+        buf = tiovx_modules_dequeue_buf(input_buf_pool);
+        v4l2_capture_enqueue_buf(v4l2_handle, buf);
+
+        if (is_IR == false)
+        {
+            h3a_buf = tiovx_modules_dequeue_buf(h3a_buf_pool);
+            aewb_buf = tiovx_modules_dequeue_buf(aewb_buf_pool);
+            aewb_process(aewb_handle, h3a_buf, aewb_buf);
+            tiovx_modules_release_buf(h3a_buf);
+            tiovx_modules_release_buf(aewb_buf);
+        }
+    }
+
+    pthread_exit(NULL);
+}
+
+void *mosaic_rgbir_enqueue(void *params)
+{
+    threadParams *thread_params = (threadParams *)params;
+    Pad *pad = thread_params->pad;
+    BufPool *buf_pool = pad->buf_pool;
+    Buf *buf = NULL;
+
+    for (int i = 0; i < APP_NUM_ITERATIONS; i++) {
+        buf = tiovx_modules_acquire_buf(buf_pool);
+        tiovx_modules_enqueue_buf(buf);
+    }
+
+    pthread_exit(NULL);
+}
+
+void *mosaic_rgbir_dequeue(void *params)
+{
+    threadParams *thread_params = (threadParams *)params;
+    Pad *pad = thread_params->pad;
+    kmsDisplayHandle *kms_display_handle = thread_params->kms_display_handle;
+    BufPool *buf_pool = pad->buf_pool;
+    Buf *buf = NULL;
+
+    for (int i = 0; i < pad->bufq_depth; i++) {
+        kms_display_register_buf(kms_display_handle, &buf_pool->bufs[i]);
+    }
+
+    for (int i = 0; i < APP_NUM_ITERATIONS; i++) {
+        buf = tiovx_modules_dequeue_buf(buf_pool);
+        kms_display_render_buf(kms_display_handle, buf);
+        tiovx_modules_release_buf(buf);
+    }
+
+    pthread_exit(NULL);
+}
+
+
+vx_status app_modules_linux_rgb_ir_display_test_tiovx_vs_gst(vx_int32 argc, vx_char* argv[])
+{
+    vx_status status = VX_FAILURE;
+    GraphObj graph;
+    NodeObj *viss_node[NUM_CAMS], *mosaic_node, *color_node, *msc_node_rgb, *msc_node_ir;
+    TIOVXVissNodeCfg viss_cfg_rgb;
+    TIOVXVissNodeCfg viss_cfg_ir;
+    TIOVXDLColorConvertNodeCfg color_cfg;
+    TIOVXMosaicNodeCfg mosaic_cfg;
+    TIOVXMultiScalerNodeCfg msc_cfg_rgb, msc_cfg_ir;
+    v4l2CaptureCfg v4l2_capture_cfg;
+    v4l2CaptureHandle *v4l2_capture_handle[NUM_CAMS];
+    kmsDisplayCfg kms_display_cfg;
+    kmsDisplayHandle *kms_display_handle;
+    AewbCfg aewb_cfg;
+    AewbHandle *aewb_handle[NUM_CAMS];
+    threadParams viss_thread_params[NUM_CAMS];
+    threadParams mosaic_thread_params;
+    pthread_t viss_enqueue_threads[NUM_CAMS], viss_dequeue_threads[NUM_CAMS];
+    pthread_t mosaic_enqueue_thread, mosaic_dequeue_thread;
+    uint8_t i;
+
+    status = tiovx_modules_initialize_graph(&graph);
+    graph.schedule_mode = VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO;
+
+    /** Configure ISP / VISS node for RGB stream  **/
+    tiovx_viss_init_cfg(&viss_cfg_rgb);
+    sprintf(viss_cfg_rgb.sensor_name, SENSOR_NAME);
+    snprintf(viss_cfg_rgb.dcc_config_file, TIVX_FILEIO_FILE_PATH_LENGTH, "%s", DCC_VISS);
+    viss_cfg_rgb.width = INPUT_WIDTH;
+    viss_cfg_rgb.height = INPUT_HEIGHT;
+    sprintf(viss_cfg_rgb.target_string, TIVX_TARGET_VPAC_VISS1);
+    viss_cfg_rgb.input_cfg.params.format[0].pixel_container = TIVX_RAW_IMAGE_16_BIT;
+    viss_cfg_rgb.input_cfg.params.format[0].msb = 9;
+    viss_cfg_rgb.enable_aewb_pad = vx_true_e;
+    viss_cfg_rgb.enable_h3a_pad = vx_true_e;
+    viss_cfg_rgb.viss_params.bypass_pcid = 0;
+    viss_cfg_rgb.viss_params.enable_ir_op = TIVX_VPAC_VISS_IR_DISABLE;
+    viss_cfg_rgb.viss_params.enable_bayer_op = TIVX_VPAC_VISS_BAYER_ENABLE;
+
+    /** Configure ISP / VISS node for Infrared stream  **/
+    tiovx_viss_init_cfg(&viss_cfg_ir);
+    sprintf(viss_cfg_ir.sensor_name, SENSOR_NAME);
+    snprintf(viss_cfg_ir.dcc_config_file, TIVX_FILEIO_FILE_PATH_LENGTH, "%s", DCC_VISS);
+    viss_cfg_ir.width = INPUT_WIDTH;
+    viss_cfg_ir.height = INPUT_HEIGHT;
+    sprintf(viss_cfg_ir.target_string, TIVX_TARGET_VPAC_VISS1);
+    viss_cfg_ir.input_cfg.params.format[0].pixel_container = TIVX_RAW_IMAGE_16_BIT;
+    viss_cfg_ir.input_cfg.params.format[0].msb = 9;
+    viss_cfg_ir.enable_aewb_pad = vx_false_e;
+    viss_cfg_ir.enable_h3a_pad = vx_false_e;
+    viss_cfg_ir.viss_params.bypass_pcid = 0;
+    viss_cfg_ir.viss_params.enable_ir_op = TIVX_VPAC_VISS_IR_ENABLE;
+    viss_cfg_ir.viss_params.enable_bayer_op = TIVX_VPAC_VISS_BAYER_DISABLE;
+
+
+    /** Configure color conversion for grayscale from Ir -> NV12 so it can combine with RGB stream at mosaic  **/
+    tiovx_dl_color_convert_init_cfg(&color_cfg);
+    color_cfg.width = WINDOW_WIDTH;
+    color_cfg.height = WINDOW_HEIGHT;
+    color_cfg.input_cfg.color_format = VX_DF_IMAGE_U8;
+    color_cfg.output_cfg.color_format = VX_DF_IMAGE_NV12;
+    sprintf(color_cfg.target_string, TIVX_TARGET_MPU_0);
+
+    /** Configure V4L2 image capture **/
+    v4l2_capture_init_cfg(&v4l2_capture_cfg);
+    v4l2_capture_cfg.width = INPUT_WIDTH;
+    v4l2_capture_cfg.height = INPUT_HEIGHT;
+    v4l2_capture_cfg.pix_format = v4l2_fourcc('B','G','I','0');
+    v4l2_capture_cfg.bufq_depth = APP_BUFQ_DEPTH;
+
+    viss_node[0] = tiovx_modules_add_node(&graph, TIOVX_VISS, (void *)&viss_cfg_rgb);
+    viss_node[0]->sinks[0].bufq_depth = APP_BUFQ_DEPTH;
+    viss_node[1] = tiovx_modules_add_node(&graph, TIOVX_VISS, (void *)&viss_cfg_ir);
+    viss_node[1]->sinks[0].bufq_depth = APP_BUFQ_DEPTH;
+
+    aewb_init_cfg(&aewb_cfg);
+    sprintf(aewb_cfg.dcc_2a_file, TIOVX_MODULES_IMAGING_PATH"/ox05b1s/linear/dcc_2a.bin");
+    sprintf(aewb_cfg.sensor_name, "SENSOR_OX05B1S");
+
+
+    /** Configure multiscaler nodes that will downscale images going into mosaic 
+    *       Technically, mosaic can also resize, but we use multiscaler before so GST and TIOVX are comparable
+    **/
+    tiovx_multi_scaler_init_cfg(&msc_cfg_rgb);
+    tiovx_multi_scaler_module_crop_params_init(&msc_cfg_rgb);
+
+    msc_cfg_rgb.color_format = VX_DF_IMAGE_NV12;
+    msc_cfg_rgb.num_outputs = 1;
+    msc_cfg_rgb.input_cfg.width = INPUT_WIDTH;
+    msc_cfg_rgb.input_cfg.height = INPUT_HEIGHT;
+    msc_cfg_rgb.output_cfgs[0].width = WINDOW_WIDTH ;
+    msc_cfg_rgb.output_cfgs[0].height = WINDOW_HEIGHT ;
+    msc_cfg_rgb.crop_params[0].crop_start_x = 0;
+    msc_cfg_rgb.crop_params[0].crop_start_y = 0;
+    msc_cfg_rgb.crop_params[0].crop_width = INPUT_WIDTH;
+    msc_cfg_rgb.crop_params[0].crop_height = INPUT_HEIGHT;
+
+    memcpy((void*) &msc_cfg_ir, (void*) &msc_cfg_rgb, sizeof(msc_cfg_rgb));
+    sprintf(msc_cfg_ir.target_string, TIVX_TARGET_VPAC_MSC2);
+    // msc_cfg_ir.color_format
+    msc_cfg_ir.color_format = VX_DF_IMAGE_U8;
+
+    /** Configure mosaic node that will join the streams  **/
+    tiovx_mosaic_init_cfg(&mosaic_cfg);
+    mosaic_cfg.color_format = VX_DF_IMAGE_NV12;
+    mosaic_cfg.num_inputs = NUM_CAMS;
+    mosaic_cfg.output_cfg.width = DISPLAY_WIDTH;
+    mosaic_cfg.output_cfg.height = DISPLAY_HEIGHT;
+    mosaic_cfg.params.num_windows  = NUM_CAMS;
+    mosaic_cfg.params.clear_count  = 4;
+
+    for (i = 0; i < NUM_CAMS; i++) {
+        mosaic_cfg.input_cfgs[i].width = WINDOW_WIDTH;
+        mosaic_cfg.input_cfgs[i].height = WINDOW_HEIGHT;
+        mosaic_cfg.params.windows[i].startX  = (i % 2) * WINDOW_WIDTH;
+        mosaic_cfg.params.windows[i].startY  = (i/2) * WINDOW_HEIGHT;
+        mosaic_cfg.params.windows[i].width   = WINDOW_WIDTH;
+        mosaic_cfg.params.windows[i].height  = WINDOW_HEIGHT;
+        mosaic_cfg.params.windows[i].input_select   = i;
+        mosaic_cfg.params.windows[i].channel_select = 0;
+        
+
+        // video4 --> RGB , video3 --> IR
+        sprintf(v4l2_capture_cfg.device, DEV, i+3);
+        v4l2_capture_handle[i] = v4l2_capture_create_handle(&v4l2_capture_cfg);
+
+        sprintf(aewb_cfg.device, SUBDEV, 2);
+        aewb_handle[i] = aewb_create_handle(&aewb_cfg);
+    }
+
+    
+
+    msc_node_rgb = tiovx_modules_add_node(&graph, TIOVX_MULTI_SCALER, (void *)&msc_cfg_rgb);
+    color_node = tiovx_modules_add_node(&graph, TIOVX_DL_COLOR_CONVERT, (void *)&color_cfg);
+    msc_node_ir = tiovx_modules_add_node(&graph, TIOVX_MULTI_SCALER, (void *)&msc_cfg_ir);
+    mosaic_node = tiovx_modules_add_node(&graph, TIOVX_MOSAIC, (void *)&mosaic_cfg);
+
+    printf("link RGB VISS -> MSC RGB\n");
+    tiovx_modules_link_pads(&viss_node[0]->srcs[0], &msc_node_rgb->sinks[0]);
+
+
+    printf("link Ir VISS -> MSC \n");
+    tiovx_modules_link_pads(&viss_node[1]->srcs[0], &msc_node_ir->sinks[0]);
+    printf("link MSC -> color convert\n");
+    tiovx_modules_link_pads(&msc_node_ir->srcs[0], &color_node->sinks[0]);
+    printf("link color convert -> Mosaic\n");
+    tiovx_modules_link_pads(&color_node->srcs[0], &mosaic_node->sinks[0]);
+
+
+    printf("link MSC RGB -> Mosaic\n");
+    tiovx_modules_link_pads(&msc_node_rgb->srcs[0], &mosaic_node->sinks[1]);
+
+    kms_display_init_cfg(&kms_display_cfg);
+    kms_display_cfg.width = DISPLAY_WIDTH;
+    kms_display_cfg.height = DISPLAY_HEIGHT;
+    kms_display_cfg.pix_format = DRM_FORMAT_NV12;
+    kms_display_handle = kms_display_create_handle(&kms_display_cfg);
+
+    status = tiovx_modules_verify_graph(&graph);
+
+    //create and join threads
+    viss_thread_params[0].is_IR = false;
+    viss_thread_params[1].is_IR = true;
+
+    printf("fork threads\n");
+
+    for (i = 0; i < NUM_CAMS; i++) {
+        viss_thread_params[i].pad = &viss_node[i]->sinks[0];
+        viss_thread_params[i].v4l2_handle = v4l2_capture_handle[i];
+        viss_thread_params[i].h3a_pad = &viss_node[i]->srcs[viss_node[0]->num_outputs - 1];
+        viss_thread_params[i].aewb_pad = &viss_node[i]->sinks[1];
+        viss_thread_params[i].aewb_handle = aewb_handle[i];
+
+        pthread_create(&viss_enqueue_threads[i], NULL, viss_rgbir_enqueue, (void *)&viss_thread_params[i]);
+        pthread_create(&viss_dequeue_threads[i], NULL, viss_rgbir_dequeue, (void *)&viss_thread_params[i]);
+    }
+
+    mosaic_thread_params.pad = &mosaic_node->srcs[0];
+    // mosaic_thread_params.pad = &msc_node_rgb->srcs[0];
+    mosaic_thread_params.kms_display_handle = kms_display_handle;
+
+
+    pthread_create(&mosaic_enqueue_thread, NULL, mosaic_rgbir_enqueue, (void *)&mosaic_thread_params);
+    pthread_create(&mosaic_dequeue_thread, NULL, mosaic_rgbir_dequeue, (void *)&mosaic_thread_params);
+
+    printf("color thread\n");
+
+
+    for (i = 0; i < APP_NUM_ITERATIONS / 60; i++) {
+        sleep(1);
+        tiovx_modules_print_performance(&graph);
+    }
+
+    for (i = 0; i < NUM_CAMS; i++) {
+        pthread_join(viss_enqueue_threads[i], NULL);
+        pthread_join(viss_dequeue_threads[i], NULL);
+    }
+
+    pthread_join(mosaic_enqueue_thread, NULL);
+    pthread_join(mosaic_dequeue_thread, NULL);
+
+    for (i = 0; i < NUM_CAMS; i++) {
+        v4l2_capture_delete_handle(v4l2_capture_handle[i]);
+        aewb_delete_handle(aewb_handle[i]);
+    }
+
+    kms_display_delete_handle(kms_display_handle);
+
+    tiovx_modules_clean_graph(&graph);
+
+    return status;
+}
diff --git a/tests/main.c b/tests/main.c
index 28d601c..79ebb65 100644
--- a/tests/main.c
+++ b/tests/main.c
@@ -66,14 +66,14 @@
 #include <stdlib.h>
 #include <tiovx_modules.h>
 
-#define APP_MODULES_TEST_COLOR_CONVERT (1)
-#define APP_MODULES_TEST_DL_COLOR_CONVERT (1)
-#define APP_MODULES_TEST_MULTI_SCALER (1)
-#define APP_MODULES_TEST_VISS (1)
-#define APP_MODULES_TEST_LDC (1)
-#define APP_MODULES_TEST_VISS_LDC_MSC (1)
-#define APP_MODULES_TEST_TEE (1)
-#define APP_MODULES_TEST_MOSAIC (1)
+#define APP_MODULES_TEST_COLOR_CONVERT (0)
+#define APP_MODULES_TEST_DL_COLOR_CONVERT (0)
+#define APP_MODULES_TEST_MULTI_SCALER (0)
+#define APP_MODULES_TEST_VISS (0)
+#define APP_MODULES_TEST_LDC (0)
+#define APP_MODULES_TEST_VISS_LDC_MSC (0)
+#define APP_MODULES_TEST_TEE (0)
+#define APP_MODULES_TEST_MOSAIC (0)
 #define APP_MODULES_TEST_CAPTURE (0)
 #define APP_MODULES_TEST_TIDL (0)
 #define APP_MODULES_TEST_DL_PRE_PROC (0)
@@ -82,21 +82,22 @@
 #define APP_MODULES_TEST_DISPLAY (0)
 #define APP_MODULES_TEST_V4L2_CAPTURE (0)
 #define APP_MODULES_TEST_LINUX_CAPTURE_DISPLAY (0)
 #define APP_MODULES_TEST_LINUX_DECODE_DISPLAY (0)
 #define APP_MODULES_TEST_LINUX_CAPTURE_ENCODE (0)
 #define APP_MODULES_TEST_LINUX_MULTI_CAPTURE_DISPLAY (0)
 #define APP_MODULES_TEST_LINUX_RGB_IR_DISPLAY (0)
+#define APP_MODULES_TEST_LINUX_RGB_IR_DISPLAY_TIOVX_VS_GST (1)
 #define APP_MODULES_TEST_CAPTURE_VISS_LDC_MSC_DISPLAY (0)
 #define APP_MODULES_TEST_CAPTURE_DL_DISPLAY (0)
-#define APP_MODULES_TEST_PYRAMID (1)
-#define APP_MODULES_TEST_SDE (1)
-#define APP_MODULES_TEST_DOF (1)
+#define APP_MODULES_TEST_PYRAMID (0)
+#define APP_MODULES_TEST_SDE (0)
+#define APP_MODULES_TEST_DOF (0)
 #define APP_MODULES_TEST_LINUX_CAPTURE_DOF (0)
 #define APP_MODULES_TEST_LINUX_DECODE_SDE (0)
-#define APP_MODULES_TEST_PIXELWISE_MULTIPLY (1)
-#define APP_MODULES_TEST_PIXELWISE_ADD (1)
-#define APP_MODULES_TEST_LUT (1)
-#define APP_MODULES_TEST_FAKESRC_FAKESINK (1)
+#define APP_MODULES_TEST_PIXELWISE_MULTIPLY (0)
+#define APP_MODULES_TEST_PIXELWISE_ADD (0)
+#define APP_MODULES_TEST_LUT (0)
+#define APP_MODULES_TEST_FAKESRC_FAKESINK (0)
 #define APP_MODULES_TEST_QNX_DECODE_DISPLAY (0)
 #define APP_MODULES_TEST_QNX_CAPTURE_ENCODE (0)
 #define APP_MODULES_TEST_LINUX_MULTI_GRAPH (0)
@@ -287,6 +288,15 @@ int main(int argc, char *argv[])
         status = app_modules_linux_rgb_ir_display_test(argc, argv);
     }
 #endif
+#if (APP_MODULES_TEST_LINUX_RGB_IR_DISPLAY_TIOVX_VS_GST)
+    if(status==0)
+    {
+        printf("Running linux rgb ir equivalent to GST application\n");
+        int app_modules_linux_rgb_ir_display_test_tiovx_vs_gst(int argc, char* argv[]);
+
+        status = app_modules_linux_rgb_ir_display_test_tiovx_vs_gst(argc, argv);
+    }
+#endif
 #if (APP_MODULES_TEST_PYRAMID)
     if(status==0)
     {
-- 
2.44.1

